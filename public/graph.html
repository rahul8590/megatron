<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  
The Callgraph is the page where the graph objects is send to the front end and been streamed to graph.html. The webpage will display all the graph details. 
-->


<html>
<body>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script> 
<script src="springy.js" type="text/javascript"></script>
<script src="springyui.js" type="text/javascript"></script>
<script src="/socket.io/socket.io.js"></script>

<script>


	
	
var graph = new Springy.Graph();
var JSON = JSON || {}; 
var socket = io.connect('http://localhost:8590');
//var call_list = [] // List of all call objects.

var redraw, g, renderer;
var width = $(document).width();
var height = $(document).height();

console.log(width+' ' + height);
/*

The Call objects are generated in the client side which needs 
to be streamed to server side as and when generated.
The current assumed structure of call object is 
call = {caller: 'func1', callee: 'func2'};



//Dummy call objects being creeated here 
var call = {"entry":190.2750000008382,"exit":190.38500000169734,"from":"b","via":"a","to":"a"}


// Newly inserted code starts here 
socket.on('init',function (data) {
	if (data == 'start') {
		socket.emit('gobjects',JSON.stringify(call)); 
		socket.emit('gobjects',JSON.stringify(call1));
		socket.emit('gobjects','end');
	}		
});
*/
socket.on('init',function (data) {
	socket.emit('gobjects','send');
});

function sleep(milliseconds) {
  var start = new Date().getTime();
  for (var i = 0; i < 1e7; i++) {
    if ((new Date().getTime() - start) > milliseconds){
      break;
    }
  }
}



	
socket.on('graph',function(data) {
	
	var nodes = {}; // creates a node list of to and from function
	var fcount = []; // maintains function count
	var call_list = JSON.parse(data);
	console.log("in graph.html the call_list is " + call_list.length);
	
	for (var i =0; i < call_list.length; i++)
	{ 
		var obj = JSON.parse(call_list[i]);	
		console.log(obj.from + ' ' + obj.to);
		

		
		if (!fcount[obj.from]) {
		    fcount[obj.from] = 0;
		}
	    fcount[obj.from]++;
	    if (!fcount[obj.to]) {
		fcount[obj.to] = 0;
	    }
	    fcount[obj.to]++;
	    
		
		
		if (fcount[obj.to]) {
		}
	
		//============ Dragon graph specific code ends here =======================//
		
		
		//================= Code for Edge Creation Via Springy ====================//

	    if (!nodes[obj.from])
		nodes[obj.from] = graph.newNode({label: obj.from});
	    if (!nodes[obj.to])
		nodes[obj.to] = graph.newNode({label: obj.to});
	    graph.newEdge(nodes[obj.from], nodes[obj.to], {color: '#00A0B0'})
		
	}  // End of For function
	nodes = {};
	sleep(1500);
	socket.emit('gobjects' ,'clear');
    
	//Generating Frequecy call table (under construction)
	//document.getElementById('fcall').value = "The function call frequency is " +JSON.stringify(fcount);
	
	
});

sleep(1000);
window.onload = function () {	
	
/* layout the graph using the Spring layout implementation */
  //var layouter = new Graph.Layout.Spring(g);
  //layouter.layout(); 
   /* draw the graph using the RaphaelJS draw implementation */
   //renderer = new Graph.Renderer.Raphael('canvas', g, width, height);
   //renderer.draw();
    
}














// Newly inserted code ends here 



jQuery(function(){
 document.getElementById('canvas').value = null; // flushing the canvas to avoid caching of objects
  var springy = window.springy = jQuery('#canvas').springy({
    graph: graph,
      nodeSelected: function(node){
	  console.log('Node selected: ' + JSON.stringify(node.data));
    }
  });
}); 



  
</script>

<canvas id="canvas"> </canvas>
<div id="fcall"></div>

</body>
</html>

