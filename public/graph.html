<!--  
The Callgraph is the page where the graph objects is send to the front end and been streamed to graph.html. The webpage will display all the graph details. 
-->


<html>
<body>
<!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script> 
<script src="springy.js" type="text/javascript"></script>
<script src="springyui.js" type="text/javascript"></script>
-->
<script type="text/javascript" src="raphael-min.js"></script>
<script type="text/javascript" src="dracula_graffle.js"></script>
<script type="text/javascript" src="jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="dracula_graph.js"></script>
<script src="/socket.io/socket.io.js"></script>

<script>


	
	
//var graph = new Springy.Graph();
var JSON = JSON || {}; 
var socket = io.connect('http://localhost:8590');
//var call_list = [] // List of all call objects.

var redraw, g, renderer;
var width = $(document).width();
var height = $(document).height();

console.log(width+' ' + height);
/*

The Call objects are generated in the client side which needs 
to be streamed to server side as and when generated.
The current assumed structure of call object is 
call = {caller: 'func1', callee: 'func2'};



//Dummy call objects being creeated here 
var call = {"entry":190.2750000008382,"exit":190.38500000169734,"from":"b","via":"a","to":"a"}


// Newly inserted code starts here 
socket.on('init',function (data) {
	if (data == 'start') {
		socket.emit('gobjects',JSON.stringify(call)); 
		socket.emit('gobjects',JSON.stringify(call1));
		socket.emit('gobjects','end');
	}		
});
*/
socket.on('init',function (data) {
	socket.emit('gobjects','send');
});

function sleep(milliseconds) {
  var start = new Date().getTime();
  for (var i = 0; i < 1e7; i++) {
    if ((new Date().getTime() - start) > milliseconds){
      break;
    }
  }
}



	
socket.on('graph',function(data) {
	
	var nodes = {}; // creates a node list of to and from function
	g = new Graph();
	var call_list = JSON.parse(data);
	console.log("in graph.html the call_list is " + call_list.length);
	
	for (var i =0; i < call_list.length; i++)
	{ 
		var obj = JSON.parse(call_list[i]);	
		console.log(obj.from + ' ' + obj.to);
		if (nodes[obj.from]) {
			if (nodes[obj.from] != obj.to)
			{
				g.addEdge(obj.from,obj.to, {directed: true});
				nodes[obj.from] = obj.to;
			}
			else { continue; }
		}
		else if (!nodes[obj.from]) {
			g.addEdge(obj.from,obj.to, {directed: true});
			nodes[obj.from] = obj.to;
		}
			
	}
	nodes = {};
	sleep(1500);
	socket.emit('gobjects' ,'clear');
	var layouter = new Graph.Layout.Spring(g);
		layouter.layout(); 
		renderer = new Graph.Renderer.Raphael('canvas', g, width, height);
		renderer.draw();
	
	
});

//g.addEdge("a","b", {directed: true});
//window.onload = function() {
//sleep(1000);
window.onload = function () {	
	
/* layout the graph using the Spring layout implementation */
  //var layouter = new Graph.Layout.Spring(g);
  //layouter.layout(); 
   /* draw the graph using the RaphaelJS draw implementation */
   //renderer = new Graph.Renderer.Raphael('canvas', g, width, height);
   //renderer.draw();
    
}














// Newly inserted code ends here 



/*
socket.on('graph', function (data) {
	var a = JSON.parse(data);
	call_list.push(a);	
});

socket.on('end',function(data) {
	  var end = JSON.parse(data);
	  if (end.status == 'complete') {
		 for (var i =0; i < call_list.length; i++)
		 { 
		graph.newEdge(graph.newNode({label: call_list[i].caller}), graph.newNode({label: call_list[i].callee}), {color: '#00A0B0'});
		}
	}
  });


jQuery(function(){
 document.getElementById('callgraph').value = null; // flushing the canvas to avoid caching of objects
  var springy = window.springy = jQuery('#callgraph').springy({
    graph: graph,
    nodeSelected: function(node){
      console.log('Node selected: ' + JSON.stringify(node.data));
    }
  });
}); 
*/



  
</script>

<div id="canvas"> </div>

</body>
</html>
